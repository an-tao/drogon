<%inc#include "create_model.h"
using namespace drogon_ctl;
%>
/**
 *
 *  [[fileName]]Base.h
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#pragma once

#include <drogon/HttpController.h>

<%c++
auto tableInfo = @@.get<DrTemplateData>("tableInfo");
auto modelName = tableInfo.get<std::string>("className");
$$<<"#include \""<<modelName<<".h\"\n";
bool hasPrimaryKey = (tableInfo.get<int>("hasPrimaryKey")==1);
$$<<"using namespace drogon;\n";

$$<<"using namespace drogon_model::"<<tableInfo.get<std::string>("dbName");
auto &schema=tableInfo.get<std::string>("schema");
if(!schema.empty())
{
    $$<<"::"<<schema<<";\n";
}
else
{
    $$<<";\n";
}

auto namespaceVector=@@.get<std::vector<std::string>>("namespaceVector");
for(auto &name:namespaceVector)
{
%>
namespace {%name%} 
{
<%c++}%>
/**
 * @brief this class is created by the drogon_ctl command.
 * this class is a restful API controller for reading and writing the [[tableName]] table.
 */

class [[className]]Base
{
  public:
<%c++if(hasPrimaryKey)
{
%>
    void getOne(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback,
                {%modelName%}::PrimaryKeyType &&id);
    void updateOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
    void deleteOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
<%c++}
%>
    void get(const HttpRequestPtr &req,
             std::function<void(const HttpResponsePtr &)> &&callback);
    void create(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback);


//  void update(const HttpRequestPtr &req,
//              std::function<void(const HttpResponsePtr &)> &&callback);

    orm::DbClientPtr getDbClient() 
    {
        return drogon::app().get{%(@@.get<bool>("isFastDbClient")?"Fast":"")%}DbClient(_dbClientName);
    }
    void enableMasquerading(const std::vector<std::string> &pMasqueradingVector)
    {
        _masquerading = true;
        _masqueradingVector = pMasqueradingVector;
    }
    void disableMasquerading()
    {
        _masquerading = false;
    }
    void registerAJsonValidator(
        const std::string &fieldName,
        const std::function<bool(const Json::Value &, std::string &)>
            &validator)
    {
        _validators.emplace_back(fieldName, validator);
    }
    void registerAJsonValidator(
        const std::string &fieldName,
        std::function<bool(const Json::Value &, std::string &)> &&validator)
    {
        _validators.emplace_back(fieldName, std::move(validator));
    }
  protected:
    /// Ensure that subclasses inherited from this class are instantiated.
    [[className]]Base(){} 
    bool doCustomValidations(const Json::Value &pJson, std::string &err);
    const std::string _dbClientName = "[[dbClientName]]";
    bool _masquerading = true;
    std::vector<
        std::pair<std::string,
                  std::function<bool(const Json::Value &, std::string &)>>>
        _validators;
    /**
     * The items in the vector are aliases of column names in the table.
     * if one item is set to an empty string, the related column is not sent to clients.
     */
    std::vector<std::string> _masqueradingVector={
<%c++ 
tableInfo = @@.get<DrTemplateData>("tableInfo");
const auto &cols=tableInfo.get<std::vector<ColumnInfo>>("columns");
for(size_t i=0; i<cols.size(); i++)
{
    auto &col = cols[i];
    if(i < (cols.size()-1))
    {
%>
          "{%col._colName%}", // the alias for the {%col._colName%} column.
<%c++
    }else{
%>
          "{%col._colName%}"  // the alias for the {%col._colName%} column.
<%c++
    }
}
%>
    };
    std::vector<std::string> fieldsSelector(const std::set<std::string> &fields)
    {
        std::vector<std::string> ret;
        for(auto &field : _masqueradingVector)
        {
            if(!field.empty() && fields.find(field) != fields.end())
            {
                ret.emplace_back(field);
            }
            else
            {
                ret.emplace_back(std::string{});
            }
        }
        return ret;
    }
    Json::Value makeJson(const HttpRequestPtr &req, const {%modelName%} &obj);
};
<%c++ for(size_t i=0;i<namespaceVector.size();++i)
{
    $$<<"}\n";
}
%>