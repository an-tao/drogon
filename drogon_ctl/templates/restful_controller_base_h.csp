<%inc#include "create_model.h"
using namespace drogon_ctl;
%>
/**
 *
 *  [[fileName]]Base.h
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#pragma once

<%c++
auto tableInfo = @@.get<DrTemplateData>("tableInfo");
auto modelName = tableInfo.get<std::string>("className");
$$<<"#include \""<<modelName<<".h\"\n";
bool hasPrimaryKey = (tableInfo.get<int>("hasPrimaryKey")==1);
$$<<"using namespace drogon;\n";

$$<<"using namespace drogon_model::"<<tableInfo.get<std::string>("dbName");
auto &schema=tableInfo.get<std::string>("schema");
if(!schema.empty())
{
    $$<<"::"<<schema<<";\n";
}
else
{
    $$<<";\n";
}

auto namespaceVector=@@.get<std::vector<std::string>>("namespaceVector");
for(auto &name:namespaceVector)
{
%>
namespace {%name%} 
{
<%c++}%>
/**
 * @brief this class is created by the drogon_ctl command.
 * this class is a restful API controller for reading and writing the [[tableName]] table.
 */

class [[className]]Base
{
  public:
<%c++if(hasPrimaryKey)
{
%>
    void getOne(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback,
                {%modelName%}::PrimaryKeyType &&id);
    void updateOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
    void deleteOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
<%c++}
%>
    void get(const HttpRequestPtr &req,
             std::function<void(const HttpResponsePtr &)> &&callback);
    void create(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback);


//    void update(const HttpRequestPtr &req,
//                std::function<void(const HttpResponsePtr &)> &&callback);

    orm::DbClientPtr getDbClient() 
    {
        return drogon::app().get{%(@@.get<bool>("isFastDbClient")?"Fast":"")%}DbClient(_dbClientName);
    }
    void enableMasquerading(const std::vector<std::string> &pMasqueradingVector)
    {
        _masquerading = true;
        _masqueradingVector = pMasqueradingVector;
    }
    void disableMasquerading()
    {
        _masquerading = false;
    }
  protected:
    const std::string _dbClientName = "[[dbClientName]]";
    bool _masquerading = true;
    /**
     * The items in the vector are aliases of column names in the table.
     * if one item is set to an empty string, the related column is not sent to clients.
     */
    std::vector<std::string> _masqueradingVector={
<%c++ 
tableInfo = @@.get<DrTemplateData>("tableInfo");
const auto &cols=tableInfo.get<std::vector<ColumnInfo>>("columns");
for(size_t i=0; i<cols.size(); i++)
{
    auto &col = cols[i];
    if(i < (cols.size()-1))
    {
%>
          "{%col._colName%}", // the alias for the {%col._colName%} column.
<%c++
    }else{
%>
          "{%col._colName%}"  // the alias for the {%col._colName%} column.
<%c++
    }
}
%>
    };
};
<%c++ for(size_t i=0;i<namespaceVector.size();++i)
{
    $$<<"}\n";
}
%>