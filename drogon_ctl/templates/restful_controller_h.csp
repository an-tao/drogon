/**
 *
 *  [[fileName]].h
 *  This file is generated by drogon_ctl
 *
 */

#pragma once

#include <drogon/HttpController.h>
<%c++
auto isForDb=@@.get<bool>("isCreatedForDatabase");
DrTemplateData tableInfo;
std::string modelName;
bool hasPrimaryKey = false;
if(isForDb)
{
    tableInfo = @@.get<DrTemplateData>("tableInfo");
    modelName = tableInfo.get<std::string>("className");
    $$<<"#include \""<<modelName<<".h\"\n";
    hasPrimaryKey = (tableInfo.get<int>("hasPrimaryKey")==1);
}
$$<<"using namespace drogon;\n";
if(isForDb)
{
    $$<<"using namespace drogon_model::"<<tableInfo.get<std::string>("dbName");
    auto &schema=tableInfo.get<std::string>("schema");
    if(!schema.empty())
    {
        $$<<"::"<<schema<<";\n";
    }
    else
    {
        $$<<";\n";
    }
}
auto namespaceVector=@@.get<std::vector<std::string>>("namespaceVector");
for(auto &name:namespaceVector)
{
%>
namespace {%name%} 
{
<%c++
 }
if(!isForDb)
{
%>
/**
 * @brief this class is created by the drogon_ctl command ([[ctlCommand]]).
 * this class is a restful API controller.
 */
<%c++
}else
{
%>
/**
 * @brief this class is created by the drogon_ctl command.
 * this class is a restful API controller for reading and writing the [[tableName]] table.
 */
<%c++
}
%>
class [[className]]: public drogon::HttpController<[[className]]>
{
  public:
    METHOD_LIST_BEGIN
    // use METHOD_ADD to add your custom processing function here;
<%c++
auto resource=@@.get<std::string>("resource");
if(resource.empty())
{
%>
    METHOD_ADD([[className]]::getOne,"/{1}",Get,Options[[filters]]);
    METHOD_ADD([[className]]::get,"",Get,Options[[filters]]);
    METHOD_ADD([[className]]::create,"",Post,Options[[filters]]);
    METHOD_ADD([[className]]::updateOne,"/{1}",Put,Options[[filters]]);
    //METHOD_ADD([[className]]::update,"",Put,Options[[filters]]);
    METHOD_ADD([[className]]::deleteOne,"/{1}",Delete,Options[[filters]]);
<%c++
}else
{
    if(hasPrimaryKey)
    {
%>
    ADD_METHOD_TO([[className]]::getOne,"{%resource%}/{1}",Get,Options[[filters]]);
    ADD_METHOD_TO([[className]]::updateOne,"{%resource%}/{1}",Put,Options[[filters]]);
    ADD_METHOD_TO([[className]]::deleteOne,"{%resource%}/{1}",Delete,Options[[filters]]);
<%c++}%>
    ADD_METHOD_TO([[className]]::get,"{%resource%}",Get,Options[[filters]]);
    ADD_METHOD_TO([[className]]::create,"{%resource%}",Post,Options[[filters]]);
    //ADD_METHOD_TO([[className]]::update,"{%resource%}",Put,Options[[filters]]);
<%c++}%>
    METHOD_LIST_END

<%c++if(isForDb)
{
    if(hasPrimaryKey)
    {
    %>
    void getOne(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback,
                {%modelName%}::PrimaryKeyType &&id);
<%c++}
}else{%>
    void getOne(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback,
                std::string &&id);
<%c++}%>
    void get(const HttpRequestPtr &req,
             std::function<void(const HttpResponsePtr &)> &&callback);
    void create(const HttpRequestPtr &req,
                std::function<void(const HttpResponsePtr &)> &&callback);
<%c++if(isForDb)
{
    if(hasPrimaryKey)
    {
    %>
    void updateOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
<%c++}
}else{%>
    void updateOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   std::string &&id);
<%c++}%>
//    void update(const HttpRequestPtr &req,
//                std::function<void(const HttpResponsePtr &)> &&callback);
<%c++if(isForDb)
{
    if(hasPrimaryKey)
    {
    %>
    void deleteOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   {%modelName%}::PrimaryKeyType &&id);
<%c++}
}else{%>
    void deleteOne(const HttpRequestPtr &req,
                   std::function<void(const HttpResponsePtr &)> &&callback,
                   std::string &&id);
<%c++}%>
  private:
    const std::string _dbClientName = "[[dbClientName]]";
};
<%c++ for(size_t i=0;i<namespaceVector.size();++i)
{
    $$<<"}\n";
}
%>